# final关键字

## final数据

1. 一个既是static又是final的域只占有一段不能改变的存储空间,全部参数要大写
2. 对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。然而对象其自身却是可以修改的

## 空白final

1.必须在域定义之处或**每个构造器**中用表达式对final进行赋值，这是final域在使用前总是被初始化的原因所在。

```java
public class BlankFinal{
    private final int i;
    
    public BlankFinal(){
        i=1;
    }
}
```

## final参数

1.在匿名内部类中传递数据 

+ 这里所说的“匿名内部类”主要是指在其外部类的成员方法内定义，同时完成实例化的类，若其访问该成员方法中的局部变量，局部变量必须要被final修饰。
+ 原因是编译程序实现上的困难：内部类对象的生命周期会超过局部变量的生命周期。局部变量的生命周期：当该方法被调用时，该方法中的局部变量在栈中被创建，当方法调用结束时，退栈，这些局部变量全部死亡。而内部类对象生命周期与其它类一样：自创建一个匿名内部类对象，系统为该对象分配内存，直到没有引用变量指向分配给该对象的内存，它才会死亡(被JVM垃圾回收)。所以完全可能出现的一种情况是：成员方法已调用结束，局部变量已死亡，但匿名内部类的对象仍然活着。
+ 如果匿名内部类的对象访问了同一个方法中的局部变量，就要求只要匿名内部类对象还活着，那么栈中的那些它要所访问的局部变量就不能“死亡”。
+ 解决方法：匿名内部类对象可以访问同一个方法中被定义为final类型的局部变量。定义为final后，编译程序的实现方法：对于匿名内部类对象要访问的所有final类型局部变量，都拷贝成为该对象中的一个数据成员。这样，即使栈中局部变量已死亡，但被定义为final类型的局部变量的值永远不变，因而匿名内部类对象在局部变量死亡后，照样可以访问final类型的局部变量，因为它自己拷贝了一份，且与原局部变量的值始终一致。


## final方法

1. privte 方法都隐士地指定为final的
2. 确保在继承中方法不被覆盖


## final类

1. final类禁止继承，所以final类中所有方法都隐士指定为final，因此无法覆盖它们。



